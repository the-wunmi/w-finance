# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `activerecord-import` gem.
# Please instead update this file by running `bin/tapioca gem activerecord-import`.


# source://activerecord-import//lib/activerecord-import/active_record/adapters/abstract_adapter.rb#5
module ActiveRecord; end

# source://activerecord-import//lib/activerecord-import/import.rb#133
class ActiveRecord::Associations::CollectionAssociation < ::ActiveRecord::Associations::Association
  # source://activerecord-import//lib/activerecord-import/import.rb#134
  def bulk_import(*args, &block); end

  # source://activerecord-import//lib/activerecord-import/import.rb#251
  def import(*args, &block); end
end

# source://activerecord-import//lib/activerecord-import/import.rb#126
class ActiveRecord::Associations::CollectionProxy < ::ActiveRecord::Relation
  # source://activerecord-import//lib/activerecord-import/import.rb#127
  def bulk_import(*args, &block); end

  # source://activerecord-import//lib/activerecord-import/import.rb#130
  def import(*args, &block); end
end

# source://activerecord-import//lib/activerecord-import/import.rb#262
class ActiveRecord::Base
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::Access
  include ::ActiveModel::Serialization
  extend ::ActiveRecord::Import::Connection

  # See ActiveRecord::ConnectionAdapters::AbstractAdapter.synchronize
  #
  # source://activerecord-import//lib/activerecord-import/synchronize.rb#64
  def synchronize(instances, key = T.unsafe(nil)); end

  class << self
    # Imports a collection of values to the database.
    #
    # This is more efficient than using ActiveRecord::Base#create or
    # ActiveRecord::Base#save multiple times. This method works well if
    # you want to create more than one record at a time and do not care
    # about having ActiveRecord objects returned for each record
    # inserted.
    #
    # This can be used with or without validations. It does not utilize
    # the ActiveRecord::Callbacks during creation/modification while
    # performing the import.
    #
    # == Usage
    #  Model.import array_of_models
    #  Model.import column_names, array_of_models
    #  Model.import array_of_hash_objects
    #  Model.import column_names, array_of_hash_objects
    #  Model.import column_names, array_of_values
    #  Model.import column_names, array_of_values, options
    #
    # ==== Model.import array_of_models
    #
    # With this form you can call _import_ passing in an array of model
    # objects that you want updated.
    #
    # ==== Model.import column_names, array_of_values
    #
    # The first parameter +column_names+ is an array of symbols or
    # strings which specify the columns that you want to update.
    #
    # The second parameter, +array_of_values+, is an array of
    # arrays. Each subarray is a single set of values for a new
    # record. The order of values in each subarray should match up to
    # the order of the +column_names+.
    #
    # ==== Model.import column_names, array_of_values, options
    #
    # The first two parameters are the same as the above form. The third
    # parameter, +options+, is a hash. This is optional. Please see
    # below for what +options+ are available.
    #
    # == Options
    # * +validate+ - true|false, tells import whether or not to use
    #   ActiveRecord validations. Validations are enforced by default.
    #   It skips the uniqueness validation for performance reasons.
    #   You can find more details here:
    #   https://github.com/zdennis/activerecord-import/issues/228
    # * +ignore+ - true|false, an alias for on_duplicate_key_ignore.
    # * +on_duplicate_key_ignore+ - true|false, tells import to discard
    #   records that contain duplicate keys. For Postgres 9.5+ it adds
    #   ON CONFLICT DO NOTHING, for MySQL it uses INSERT IGNORE, and for
    #   SQLite it uses INSERT OR IGNORE. Cannot be enabled on a
    #   recursive import. For database adapters that normally support
    #   setting primary keys on imported objects, this option prevents
    #   that from occurring.
    # * +on_duplicate_key_update+ - :all, an Array, or Hash, tells import to
    #   use MySQL's ON DUPLICATE KEY UPDATE or Postgres/SQLite ON CONFLICT
    #   DO UPDATE ability. See On Duplicate Key Update below.
    # * +synchronize+ - an array of ActiveRecord instances for the model
    #   that you are currently importing data into. This synchronizes
    #   existing model instances in memory with updates from the import.
    # * +timestamps+ - true|false, tells import to not add timestamps
    #   (if false) even if record timestamps is disabled in ActiveRecord::Base
    # * +recursive+ - true|false, tells import to import all has_many/has_one
    #   associations if the adapter supports setting the primary keys of the
    #   newly imported objects. PostgreSQL only.
    # * +batch_size+ - an integer value to specify the max number of records to
    #   include per insert. Defaults to the total number of records to import.
    #
    # == Examples
    #  class BlogPost < ActiveRecord::Base ; end
    #
    #  # Example using array of model objects
    #  posts = [ BlogPost.new author_name: 'Zach Dennis', title: 'AREXT',
    #            BlogPost.new author_name: 'Zach Dennis', title: 'AREXT2',
    #            BlogPost.new author_name: 'Zach Dennis', title: 'AREXT3' ]
    #  BlogPost.import posts
    #
    #  # Example using array_of_hash_objects
    #  # NOTE: column_names will be determined by using the keys of the first hash in the array. If later hashes in the
    #  # array have different keys an exception will be raised. If you have hashes to import with different sets of keys
    #  # we recommend grouping these into batches before importing.
    #  values = [ {author_name: 'zdennis', title: 'test post'} ], [ {author_name: 'jdoe', title: 'another test post'} ] ]
    #  BlogPost.import values
    #
    #  # Example using column_names and array_of_hash_objects
    #  columns = [ :author_name, :title ]
    #  values = [ {author_name: 'zdennis', title: 'test post'} ], [ {author_name: 'jdoe', title: 'another test post'} ] ]
    #  BlogPost.import columns, values
    #
    #  # Example using column_names and array_of_values
    #  columns = [ :author_name, :title ]
    #  values = [ [ 'zdennis', 'test post' ], [ 'jdoe', 'another test post' ] ]
    #  BlogPost.import columns, values
    #
    #  # Example using column_names, array_of_value and options
    #  columns = [ :author_name, :title ]
    #  values = [ [ 'zdennis', 'test post' ], [ 'jdoe', 'another test post' ] ]
    #  BlogPost.import( columns, values, validate: false  )
    #
    #  # Example synchronizing existing instances in memory
    #  post = BlogPost.where(author_name: 'zdennis').first
    #  puts post.author_name # => 'zdennis'
    #  columns = [ :author_name, :title ]
    #  values = [ [ 'yoda', 'test post' ] ]
    #  BlogPost.import posts, synchronize: [ post ]
    #  puts post.author_name # => 'yoda'
    #
    #  # Example synchronizing unsaved/new instances in memory by using a uniqued imported field
    #  posts = [BlogPost.new(title: "Foo"), BlogPost.new(title: "Bar")]
    #  BlogPost.import posts, synchronize: posts, synchronize_keys: [:title]
    #  puts posts.first.persisted? # => true
    #
    # == On Duplicate Key Update (MySQL)
    #
    # The :on_duplicate_key_update option can be either :all, an Array, or a Hash.
    #
    # ==== Using :all
    #
    # The :on_duplicate_key_update option can be set to :all. All columns
    # other than the primary key are updated. If a list of column names is
    # supplied, only those columns will be updated. Below is an example:
    #
    #   BlogPost.import columns, values, on_duplicate_key_update: :all
    #
    # ==== Using an Array
    #
    # The :on_duplicate_key_update option can be an array of column
    # names. The column names are the only fields that are updated if
    # a duplicate record is found. Below is an example:
    #
    #   BlogPost.import columns, values, on_duplicate_key_update: [ :date_modified, :content, :author ]
    #
    # ====  Using A Hash
    #
    # The :on_duplicate_key_update option can be a hash of column names
    # to model attribute name mappings. This gives you finer grained
    # control over what fields are updated with what attributes on your
    # model. Below is an example:
    #
    #   BlogPost.import columns, attributes, on_duplicate_key_update: { title: :title }
    #
    # == On Duplicate Key Update (Postgres 9.5+ and SQLite 3.24+)
    #
    # The :on_duplicate_key_update option can be :all, an Array, or a Hash with up to
    # three attributes, :conflict_target (and optionally :index_predicate) or
    # :constraint_name (Postgres), and :columns.
    #
    # ==== Using :all
    #
    # The :on_duplicate_key_update option can be set to :all. All columns
    # other than the primary key are updated. If a list of column names is
    # supplied, only those columns will be updated. Below is an example:
    #
    #   BlogPost.import columns, values, on_duplicate_key_update: :all
    #
    # ==== Using an Array
    #
    # The :on_duplicate_key_update option can be an array of column
    # names. This option only handles inserts that conflict with the
    # primary key. If a table does not have a primary key, this will
    # not work. The column names are the only fields that are updated
    # if a duplicate record is found. Below is an example:
    #
    #   BlogPost.import columns, values, on_duplicate_key_update: [ :date_modified, :content, :author ]
    #
    # ====  Using a Hash
    #
    # The :on_duplicate_key_update option can be a hash with up to three
    # attributes, :conflict_target (and optionally :index_predicate) or
    # :constraint_name, and :columns. Unlike MySQL, Postgres requires the
    # conflicting constraint to be explicitly specified. Using this option
    # allows you to specify a constraint other than the primary key.
    #
    # ===== :conflict_target
    #
    # The :conflict_target attribute specifies the columns that make up the
    # conflicting unique constraint and can be a single column or an array of
    # column names. This attribute is ignored if :constraint_name is included,
    # but it is the preferred method of identifying a constraint. It will
    # default to the primary key. Below is an example:
    #
    #   BlogPost.import columns, values, on_duplicate_key_update: { conflict_target: [ :author_id, :slug ], columns: [ :date_modified ] }
    #
    # ===== :index_predicate
    #
    # The :index_predicate attribute optionally specifies a WHERE condition
    # on :conflict_target, which is required for matching against partial
    # indexes. This attribute is ignored if :constraint_name is included.
    # Below is an example:
    #
    #   BlogPost.import columns, values, on_duplicate_key_update: { conflict_target: [ :author_id, :slug ], index_predicate: 'status <> 0', columns: [ :date_modified ] }
    #
    # ===== :constraint_name
    #
    # The :constraint_name attribute explicitly identifies the conflicting
    # unique index by name. Postgres documentation discourages using this method
    # of identifying an index unless absolutely necessary. Below is an example:
    #
    #   BlogPost.import columns, values, on_duplicate_key_update: { constraint_name: :blog_posts_pkey, columns: [ :date_modified ] }
    #
    # ===== :condition
    #
    # The :condition attribute optionally specifies a WHERE condition
    # on :conflict_action. Only rows for which this expression returns true will be updated.
    # Note that it's evaluated last, after a conflict has been identified as a candidate to update.
    # Below is an example:
    #
    #   BlogPost.import columns, values, on_duplicate_key_update: { conflict_target: [ :author_id ], condition: "blog_posts.title NOT LIKE '%sample%'", columns: [ :author_name ] }
    #
    # ===== :columns
    #
    # The :columns attribute can be either :all, an Array, or a Hash.
    #
    # ===== Using :all
    #
    # The :columns attribute can be :all. All columns other than the primary key will be updated.
    # If a list of column names is supplied, only those columns will be updated.
    # Below is an example:
    #
    #   BlogPost.import columns, values, on_duplicate_key_update: { conflict_target: :slug, columns: :all }
    #
    # ===== Using an Array
    #
    # The :columns attribute can be an array of column names. The column names
    # are the only fields that are updated if a duplicate record is found.
    # Below is an example:
    #
    #   BlogPost.import columns, values, on_duplicate_key_update: { conflict_target: :slug, columns: [ :date_modified, :content, :author ] }
    #
    # =====  Using a Hash
    #
    # The :columns option can be a hash of column names to model attribute name
    # mappings. This gives you finer grained control over what fields are updated
    # with what attributes on your model. Below is an example:
    #
    #   BlogPost.import columns, attributes, on_duplicate_key_update: { conflict_target: :slug, columns: { title: :title } }
    #
    # = Returns
    # This returns an object which responds to +failed_instances+ and +num_inserts+.
    # * failed_instances - an array of objects that fails validation and were not committed to the database. An empty array if no validation is performed.
    # * num_inserts - the number of insert statements it took to import the data
    # * ids - the primary keys of the imported ids if the adapter supports it, otherwise an empty array.
    # * results - import results if the adapter supports it, otherwise an empty array.
    #
    # source://activerecord-import//lib/activerecord-import/import.rb#530
    def bulk_import(*args); end

    # Imports a collection of values if all values are valid. Import fails at the
    # first encountered validation error and raises ActiveRecord::RecordInvalid
    # with the failed instance.
    #
    # source://activerecord-import//lib/activerecord-import/import.rb#546
    def bulk_import!(*args); end

    # source://activerecord-import//lib/activerecord-import/import.rb#541
    def import(*args); end

    # source://activerecord-import//lib/activerecord-import/import.rb#553
    def import!(*args); end

    # source://activerecord-import//lib/activerecord-import/import.rb#555
    def import_helper(*args); end

    # Imports the passed in +column_names+ and +array_of_attributes+
    # given the passed in +options+ Hash with validations. Returns an
    # object with the methods +failed_instances+ and +num_inserts+.
    # +failed_instances+ is an array of instances that failed validations.
    # +num_inserts+ is the number of inserts it took to import the data. See
    # ActiveRecord::Base.import for more information on
    # +column_names+, +array_of_attributes+ and +options+.
    #
    # @yield [failed_instances]
    #
    # source://activerecord-import//lib/activerecord-import/import.rb#763
    def import_with_validations(column_names, array_of_attributes, options = T.unsafe(nil)); end

    # Imports the passed in +column_names+ and +array_of_attributes+
    # given the passed in +options+ Hash. This will return the number
    # of insert operations it took to create these records without
    # validations or callbacks. See ActiveRecord::Base.import for more
    # information on +column_names+, +array_of_attributes_ and
    # +options+.
    #
    # source://activerecord-import//lib/activerecord-import/import.rb#782
    def import_without_validations_or_callbacks(column_names, array_of_attributes, options = T.unsafe(nil)); end

    # Returns true if the current database connection adapter
    # supports import functionality, otherwise returns false.
    #
    # @return [Boolean]
    #
    # source://activerecord-import//lib/activerecord-import/import.rb#268
    def supports_import?(*args); end

    # Returns true if the current database connection adapter
    # supports on duplicate key update functionality, otherwise
    # returns false.
    #
    # @return [Boolean]
    #
    # source://activerecord-import//lib/activerecord-import/import.rb#275
    def supports_on_duplicate_key_update?; end

    # returns true if the current database connection adapter
    # supports setting the primary key of bulk imported models, otherwise
    # returns false
    #
    # @return [Boolean]
    #
    # source://activerecord-import//lib/activerecord-import/import.rb#282
    def supports_setting_primary_key_of_imported_objects?; end

    # Synchronizes the passed in ActiveRecord instances with data
    # from the database. This is like calling reload on an individual
    # ActiveRecord instance but it is intended for use on multiple instances.
    #
    # This uses one query for all instance updates and then updates existing
    # instances rather sending one query for each instance
    #
    # == Examples
    # # Synchronizing existing models by matching on the primary key field
    # posts = Post.where(author: "Zach").first
    # <.. out of system changes occur to change author name from Zach to Zachary..>
    # Post.synchronize posts
    # posts.first.author # => "Zachary" instead of Zach
    #
    # # Synchronizing using custom key fields
    # posts = Post.where(author: "Zach").first
    # <.. out of system changes occur to change the address of author 'Zach' to 1245 Foo Ln ..>
    # Post.synchronize posts, [:name] # queries on the :name column and not the :id column
    # posts.first.address # => "1245 Foo Ln" instead of whatever it was
    #
    # source://activerecord-import//lib/activerecord-import/synchronize.rb#25
    def synchronize(instances, keys = T.unsafe(nil)); end

    private

    # source://activerecord-import//lib/activerecord-import/import.rb#1069
    def add_special_rails_stamps(column_names, array_of_attributes, options); end

    # source://activerecord-import//lib/activerecord-import/import.rb#860
    def associated_options(options, association); end

    # We are eventually going to call Class.import <objects> so we build up a hash
    # of class => objects to import.
    #
    # source://activerecord-import//lib/activerecord-import/import.rb#993
    def find_associated_objects_for_import(associated_objects_by_class, model); end

    # source://activerecord-import//lib/activerecord-import/import.rb#958
    def import_associations(models, options); end

    # Sync belongs_to association ids with foreign key field
    #
    # source://activerecord-import//lib/activerecord-import/import.rb#938
    def load_association_ids(model); end

    # source://activerecord-import//lib/activerecord-import/import.rb#983
    def schema_columns_hash; end

    # source://activerecord-import//lib/activerecord-import/import.rb#868
    def set_attributes_and_mark_clean(models, import_result, timestamps, options); end

    # Checks that the imported hash has the required_keys, optionally also checks that the hash has
    # no keys beyond those required when `allow_extra_keys` is false.
    # returns `nil` if validation passes, or an error message if it fails
    #
    # source://activerecord-import//lib/activerecord-import/import.rb#1121
    def validate_hash_import(hash, required_keys, allow_extra_keys); end

    # Returns an Array of Hashes for the passed in +column_names+ and +array_of_attributes+.
    #
    # source://activerecord-import//lib/activerecord-import/import.rb#1114
    def validations_array_for_column_names_and_attributes(column_names, array_of_attributes); end

    # Returns SQL the VALUES for an INSERT statement given the passed in +columns+
    # and +array_of_attributes+.
    #
    # source://activerecord-import//lib/activerecord-import/import.rb#1032
    def values_sql_for_columns_and_attributes(columns, array_of_attributes); end
  end
end

# source://activerecord-import//lib/activerecord-import/active_record/adapters/abstract_adapter.rb#6
module ActiveRecord::ConnectionAdapters; end

# source://activerecord-import//lib/activerecord-import/active_record/adapters/abstract_adapter.rb#7
class ActiveRecord::ConnectionAdapters::AbstractAdapter
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::Import::AbstractAdapter::InstanceMethods
end

# source://activerecord-import//lib/activerecord-import/base.rb#7
module ActiveRecord::Import
  class << self
    # source://activerecord-import//lib/activerecord-import/base.rb#10
    def base_adapter(adapter); end

    # Loads the import functionality for the passed in ActiveRecord connection
    #
    # source://activerecord-import//lib/activerecord-import/base.rb#35
    def load_from_connection_pool(connection_pool); end

    # Loads the import functionality for a specific database adapter
    #
    # source://activerecord-import//lib/activerecord-import/base.rb#28
    def require_adapter(adapter); end
  end
end

# source://activerecord-import//lib/activerecord-import/base.rb#8
ActiveRecord::Import::ADAPTER_PATH = T.let(T.unsafe(nil), String)

# source://activerecord-import//lib/activerecord-import/adapters/abstract_adapter.rb#3
module ActiveRecord::Import::AbstractAdapter; end

# source://activerecord-import//lib/activerecord-import/adapters/abstract_adapter.rb#4
module ActiveRecord::Import::AbstractAdapter::InstanceMethods
  # Synchronizes the passed in ActiveRecord instances with the records in
  # the database by calling +reload+ on each instance.
  #
  # source://activerecord-import//lib/activerecord-import/adapters/abstract_adapter.rb#42
  def after_import_synchronize(instances); end

  # source://activerecord-import//lib/activerecord-import/adapters/abstract_adapter.rb#65
  def increment_locking_column!(table_name, results, locking_column); end

  # source://activerecord-import//lib/activerecord-import/adapters/abstract_adapter.rb#9
  def insert_many(sql, values, _options = T.unsafe(nil), *args); end

  # source://activerecord-import//lib/activerecord-import/adapters/abstract_adapter.rb#5
  def next_value_for_sequence(sequence_name); end

  # Returns an array of post SQL statements given the passed in options.
  #
  # source://activerecord-import//lib/activerecord-import/adapters/abstract_adapter.rb#47
  def post_sql_statements(table_name, options); end

  # source://activerecord-import//lib/activerecord-import/adapters/abstract_adapter.rb#25
  def pre_sql_statements(options); end

  # @return [Boolean]
  #
  # source://activerecord-import//lib/activerecord-import/adapters/abstract_adapter.rb#71
  def supports_on_duplicate_key_update?; end
end

# source://activerecord-import//lib/activerecord-import/import.rb#254
module ActiveRecord::Import::Connection
  # source://activerecord-import//lib/activerecord-import/import.rb#255
  def establish_connection(args = T.unsafe(nil)); end
end

# source://activerecord-import//lib/activerecord-import/import.rb#3
module ActiveRecord::Import::ConnectionAdapters; end

# source://activerecord-import//lib/activerecord-import/import.rb#8
module ActiveRecord::Import::ImportSupport
  # @return [Boolean]
  #
  # source://activerecord-import//lib/activerecord-import/import.rb#9
  def supports_import?; end
end

# source://activerecord-import//lib/activerecord-import/import.rb#20
class ActiveRecord::Import::MissingColumnError < ::StandardError
  # @return [MissingColumnError] a new instance of MissingColumnError
  #
  # source://activerecord-import//lib/activerecord-import/import.rb#21
  def initialize(name, index); end
end

# source://activerecord-import//lib/activerecord-import/import.rb#14
module ActiveRecord::Import::OnDuplicateKeyUpdateSupport
  # @return [Boolean]
  #
  # source://activerecord-import//lib/activerecord-import/import.rb#15
  def supports_on_duplicate_key_update?; end
end

# source://activerecord-import//lib/activerecord-import/import.rb#6
class ActiveRecord::Import::Result < ::Struct
  # Returns the value of attribute failed_instances
  #
  # @return [Object] the current value of failed_instances
  #
  # source://activerecord-import//lib/activerecord-import/import.rb#6
  def failed_instances; end

  # Sets the attribute failed_instances
  #
  # @param value [Object] the value to set the attribute failed_instances to.
  # @return [Object] the newly set value
  #
  # source://activerecord-import//lib/activerecord-import/import.rb#6
  def failed_instances=(_); end

  # Returns the value of attribute ids
  #
  # @return [Object] the current value of ids
  #
  # source://activerecord-import//lib/activerecord-import/import.rb#6
  def ids; end

  # Sets the attribute ids
  #
  # @param value [Object] the value to set the attribute ids to.
  # @return [Object] the newly set value
  #
  # source://activerecord-import//lib/activerecord-import/import.rb#6
  def ids=(_); end

  # Returns the value of attribute num_inserts
  #
  # @return [Object] the current value of num_inserts
  #
  # source://activerecord-import//lib/activerecord-import/import.rb#6
  def num_inserts; end

  # Sets the attribute num_inserts
  #
  # @param value [Object] the value to set the attribute num_inserts to.
  # @return [Object] the newly set value
  #
  # source://activerecord-import//lib/activerecord-import/import.rb#6
  def num_inserts=(_); end

  # Returns the value of attribute results
  #
  # @return [Object] the current value of results
  #
  # source://activerecord-import//lib/activerecord-import/import.rb#6
  def results; end

  # Sets the attribute results
  #
  # @param value [Object] the value to set the attribute results to.
  # @return [Object] the newly set value
  #
  # source://activerecord-import//lib/activerecord-import/import.rb#6
  def results=(_); end

  class << self
    # source://activerecord-import//lib/activerecord-import/import.rb#6
    def [](*_arg0); end

    # source://activerecord-import//lib/activerecord-import/import.rb#6
    def inspect; end

    # source://activerecord-import//lib/activerecord-import/import.rb#6
    def keyword_init?; end

    # source://activerecord-import//lib/activerecord-import/import.rb#6
    def members; end

    # source://activerecord-import//lib/activerecord-import/import.rb#6
    def new(*_arg0); end
  end
end

# source://activerecord-import//lib/activerecord-import/import.rb#26
class ActiveRecord::Import::Validator
  # @return [Validator] a new instance of Validator
  #
  # source://activerecord-import//lib/activerecord-import/import.rb#27
  def initialize(klass, options = T.unsafe(nil)); end

  # source://activerecord-import//lib/activerecord-import/import.rb#33
  def init_validations(klass); end

  # @return [Boolean]
  #
  # source://activerecord-import//lib/activerecord-import/import.rb#74
  def valid_model?(model); end
end

# source://activerecord-import//lib/activerecord-import/value_sets_parser.rb#6
class ActiveRecord::Import::ValueSetTooLargeError < ::StandardError
  # @return [ValueSetTooLargeError] a new instance of ValueSetTooLargeError
  #
  # source://activerecord-import//lib/activerecord-import/value_sets_parser.rb#9
  def initialize(msg = T.unsafe(nil), size = T.unsafe(nil)); end

  # Returns the value of attribute size.
  #
  # source://activerecord-import//lib/activerecord-import/value_sets_parser.rb#7
  def size; end
end

# source://activerecord-import//lib/activerecord-import/value_sets_parser.rb#15
class ActiveRecord::Import::ValueSetsBytesParser
  # @return [ValueSetsBytesParser] a new instance of ValueSetsBytesParser
  #
  # source://activerecord-import//lib/activerecord-import/value_sets_parser.rb#22
  def initialize(values, options); end

  # Returns the value of attribute max_bytes.
  #
  # source://activerecord-import//lib/activerecord-import/value_sets_parser.rb#16
  def max_bytes; end

  # source://activerecord-import//lib/activerecord-import/value_sets_parser.rb#28
  def parse; end

  # Returns the value of attribute reserved_bytes.
  #
  # source://activerecord-import//lib/activerecord-import/value_sets_parser.rb#16
  def reserved_bytes; end

  # Returns the value of attribute values.
  #
  # source://activerecord-import//lib/activerecord-import/value_sets_parser.rb#16
  def values; end

  private

  # source://activerecord-import//lib/activerecord-import/value_sets_parser.rb#59
  def default_max_bytes; end

  class << self
    # source://activerecord-import//lib/activerecord-import/value_sets_parser.rb#18
    def parse(values, options); end
  end
end

# source://activerecord-import//lib/activerecord-import/value_sets_parser.rb#66
class ActiveRecord::Import::ValueSetsRecordsParser
  # @return [ValueSetsRecordsParser] a new instance of ValueSetsRecordsParser
  #
  # source://activerecord-import//lib/activerecord-import/value_sets_parser.rb#73
  def initialize(values, options); end

  # Returns the value of attribute max_records.
  #
  # source://activerecord-import//lib/activerecord-import/value_sets_parser.rb#67
  def max_records; end

  # source://activerecord-import//lib/activerecord-import/value_sets_parser.rb#78
  def parse; end

  # Returns the value of attribute values.
  #
  # source://activerecord-import//lib/activerecord-import/value_sets_parser.rb#67
  def values; end

  class << self
    # source://activerecord-import//lib/activerecord-import/value_sets_parser.rb#69
    def parse(values, options); end
  end
end
